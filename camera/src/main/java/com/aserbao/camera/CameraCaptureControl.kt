package com.aserbao.camera

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.ImageFormat
import android.graphics.SurfaceTexture
import android.hardware.camera2.*
import android.media.ImageReader
import android.media.MediaRecorder
import android.os.Build
import android.os.Environment
import android.os.HandlerThread
import android.util.Size
import android.view.Surface
import android.widget.Toast
import androidx.core.app.ActivityCompat
import com.aserbao.camera.utils.CameraOperaion
import com.aserbao.camera.utils.ImageSaver
import com.getremark.base.kotlin_ext.runOnMainThread
import java.io.File
import java.io.IOException
import java.util.*

/*
 * 作用：
 * @author aserbao
 * @date: on 2020/10/19
 * @project: AserbaosAndroid
 * @package: com.aserbao.camera
 */
class CameraCaptureControl(var context: Context, var mCamera2View: Camera2View) : ICamera {
    companion object{
        const val IMAGE_WIDTH = 1920
        const val IMAGE_HEIHGT = 1080

        /**
         * Camera state: Showing camera preview.
         */
        val CAMERA_STATE_PREVIEW = 0
        /**
         * Camera state: Waiting for the focus to be locked.
         */
        val CAMERA_STATE_WAITING_LOCK = 2
        /**
         * Camera state: Waiting for the exposure to be precapture state.
         */
        val CAMERA_STATE_WAITING_PRECAPTURE = 3
        /**
         * Camera state: Waiting for the exposure state to be something other than precapture.
         */
        val CAMERA_STATE_WAITING_NON_PRECAPTURE = 4
        /**
         * Camera state: Picture was taken.
         */
        val CAMERA_STATE_PICTURE_TAKEN = 5
        /**
         * 录制中
         */
        val CAMERA_STATE_START_RECORDING = 5
        val CAMERA_STATE_PAUSE = 6
        /**
         * 结束录制
         */
        val CAMERA_STATE_STOP_RECORDING = 7
    }

    /**
     * Whether the current camera device supports Flash or not.
     */
    private var flashSupported = false
    var cameraAction:Int = CAMERA_STATE_PREVIEW


    open var cameraDevice:CameraDevice ?= null
    private var captureRequest: CaptureRequest? = null
    var mCameraCharacteristics:CameraCharacteristics ?= null
    private var mediaRecorder: MediaRecorder? = null
    /**
     * The [android.util.Size] of video recording.
     */
    private lateinit var videoSize: Size
    private lateinit var previewSize: Size // 最适合的尺寸
    private var imageReader: ImageReader? = null


    /**
     * This is the output file for our picture.
     */
    private lateinit var picFile: File
    /**
     * This a callback object for the [ImageReader]. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    val onImageAvailableListener =  ImageReader.OnImageAvailableListener {
        Thread(ImageSaver(it.acquireNextImage(), picFile)).start()
    }

    /**
     * A reference to the current [android.hardware.camera2.CameraCaptureSession] for
     * preview.
     */
    private var captureSession: CameraCaptureSession? = null

    /**
     * [CaptureRequest.Builder] for the camera preview
     */
    private lateinit var previewRequestBuilder: CaptureRequest.Builder
    /**
     * [CaptureRequest] generated by [.previewRequestBuilder]
     */
    private lateinit var previewRequest: CaptureRequest

    protected var mIHandleCameraListener:IHandleCameraListener ?= null


    var mStateCall = object: CameraDevice.StateCallback() {
        override fun onOpened(camera: CameraDevice) {
            cameraDevice = camera;
            startPreview()
        }

        override fun onDisconnected(camera: CameraDevice) {
            camera.close()
            cameraDevice = null
        }
        override fun onError(camera: CameraDevice, error: Int) {}
    }




    /**
     * 打开相机权限
     * @param holder
     */
    override fun openCamera(cId: Int, width: Int, height: Int) {
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            Toast.makeText(context, "请提供相机权限", Toast.LENGTH_SHORT).show()
            return
        }
        val mCameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        var usedCameraId: String = cId.toString()
        try {
            if (mCameraManager != null) {
                for (cameraId in mCameraManager.getCameraIdList()) {
                    mCameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId)
                    val facing: Int = mCameraCharacteristics!!.get(CameraCharacteristics.LENS_FACING)!!
                    if (facing != null && cId == facing) {
                        usedCameraId = cameraId
                        // Check if the flash is supported.
                        flashSupported =
                            mCameraCharacteristics?.get(CameraCharacteristics.FLASH_INFO_AVAILABLE) == true
                        setupCameraCharacteristics(mCameraCharacteristics!!,width,height)
                        break
                    }
                }
            }
            mCameraManager.openCamera(usedCameraId!!,mStateCall,null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    /**
     * 拍照
     */
    override fun capturePic(picName: String, ihandle: IHandleCameraListener) {
        mIHandleCameraListener = ihandle
        picFile = File(createPicFileName(context,"$picName.jpg"))
        lockFocus()
    }

    /**
     * 获取适应的尺寸
     * @param characteristics CameraCharacteristics
     * @param width Int
     * @param height Int
     */
    private fun setupCameraCharacteristics(characteristics: CameraCharacteristics,width: Int,height: Int) {
        val map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP) ?:
        throw RuntimeException("Cannot get available preview/video sizes")
        videoSize = chooseVideoSize(map.getOutputSizes(MediaRecorder::class.java))
        var outputSizes = map.getOutputSizes(SurfaceTexture::class.java)
        previewSize = CameraOperaion.chooseOptimalSize(outputSizes,mCamera2View.width,mCamera2View.height,1920,1080,mCamera2View.mRatioWH)!!

        CameraOperaion.chooseOptimalPicSize(map.getOutputSizes(ImageFormat.JPEG),IMAGE_WIDTH,
            IMAGE_HEIHGT,mCamera2View.mRatioWH)
        imageReader = ImageReader.newInstance(previewSize.width, previewSize.height,
            ImageFormat.JPEG, 2).apply {
            setOnImageAvailableListener(onImageAvailableListener, null)
        }
    }

    /**
     * we don't use sizes larger than 1080p,MediaRecorder cannot handle such a high-resolution video
     * @param choices Array<Size>
     * @return Size
     */
    private fun chooseVideoSize(choices: Array<Size>) = choices.firstOrNull {
        it.width == ((it.height / mCamera2View.mRatioWH).toInt()) && it.width <= 1080 } ?: choices[choices.size - 1]



    /**
     * [CameraDevice.StateCallback] is called when [CameraDevice] changes its status.
     */
    private fun startPreview() {
            var surfaceTexture = mCamera2View.surfaceTexture
            surfaceTexture.setDefaultBufferSize(previewSize.width,previewSize.height)
            val surface = Surface(surfaceTexture)

            previewRequestBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            previewRequestBuilder.addTarget(surface)
            try {
                cameraDevice?.createCaptureSession(Arrays.asList(surface,imageReader?.surface), object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        if(cameraDevice == null) return
                        captureSession = session
                        updatePreview()
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {}
                }, null)
            } catch (e: CameraAccessException) {
                e.printStackTrace()
            }
    }

    fun updatePreview(){
        try {
//            previewRequestBuilder?.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO)
            previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
            // Flash is automatically enabled when necessary.
            setAutoFlash(previewRequestBuilder)
//            HandlerThread("CameraPreview").start()
            previewRequest = previewRequestBuilder.build()
            captureSession?.setRepeatingRequest(previewRequest, captureCallback, null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    private fun setAutoFlash(requestBuilder: CaptureRequest.Builder) {
        if (flashSupported) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,
                CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH)
        }
    }


    /**
     * 创造对应的图片文件路径
     * @param context
     * @param fileName
     * @return
     */
    fun createPicFileName(context: Context, fileName: String): String? {
        val externalStorageState = Environment.getExternalStorageState()
        return if (externalStorageState == Environment.MEDIA_MOUNTED) {
            val file = File(Environment.getExternalStorageDirectory().absolutePath + "/" + "spot/pic/"
                + fileName)
            if (!file.parentFile.exists()) {
                file.parentFile.mkdirs()
            }
            file.absolutePath
        } else {
            context.filesDir.toString() + "/" + fileName
        }
    }

    // ===================== about capture ==============

    /**
     * Lock the focus as the first step for a still image capture.
     */
    fun lockFocus(){
        try {
            // This is how to tell the camera to lock focus.
            previewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                CameraMetadata.CONTROL_AF_TRIGGER_START)
            // Tell #captureCallback to wait for the lock.
            cameraAction = CAMERA_STATE_WAITING_LOCK
            captureSession?.capture(previewRequestBuilder.build(), captureCallback,null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
            mIHandleCameraListener?.error(e)
        }
    }


    /**
     * Unlock the focus. This method should be called when still image capture sequence is
     * finished.
     */
    private fun unlockFocus() {
        try {
            // Reset the auto-focus trigger
            previewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                CameraMetadata.CONTROL_AF_TRIGGER_CANCEL)
            captureSession?.capture(previewRequestBuilder.build(), captureCallback, null)
            // After this, the camera will go back to the normal state of preview.
            cameraAction = CAMERA_STATE_PREVIEW
            captureSession?.setRepeatingRequest(previewRequest, captureCallback, null)
        } catch (e: CameraAccessException) {
            mIHandleCameraListener?.error(e)
        }
    }


    private val captureCallback = object:CameraCaptureSession.CaptureCallback(){

        fun process(result:CaptureResult){
            when (cameraAction) {
                CAMERA_STATE_PREVIEW -> Unit
                CAMERA_STATE_WAITING_LOCK -> capturePicture(result)
                CAMERA_STATE_WAITING_PRECAPTURE -> {
                    // CONTROL_AE_STATE can be null on some devices
                    val aeState = result.get(CaptureResult.CONTROL_AE_STATE)
                    if (aeState == null ||
                        aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||
                        aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {
                        cameraAction = CAMERA_STATE_WAITING_NON_PRECAPTURE
                    }
                }
                CAMERA_STATE_WAITING_NON_PRECAPTURE -> {
                    // CONTROL_AE_STATE can be null on some devices
                    val aeState = result.get(CaptureResult.CONTROL_AE_STATE)
                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {
                        cameraAction = CAMERA_STATE_PICTURE_TAKEN
                        captureStillPicture()
                    }
                }
            }
        }

        private fun capturePicture(result: CaptureResult) {
            val afState = result.get(CaptureResult.CONTROL_AF_STATE)
            if (afState == null) {
                captureStillPicture()
            } else if (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED
                || afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED) {
                // CONTROL_AE_STATE can be null on some devices
                val aeState = result.get(CaptureResult.CONTROL_AE_STATE)
                if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {
                    cameraAction = CAMERA_STATE_PICTURE_TAKEN
                    captureStillPicture()
                } else {
                    runPrecaptureSequence()
                }
            }
        }

        override fun onCaptureCompleted(
            session: CameraCaptureSession,
            request: CaptureRequest,
            result: TotalCaptureResult
        ) {
            process(result)
        }

        override fun onCaptureProgressed(
            session: CameraCaptureSession,
            request: CaptureRequest,
            partialResult: CaptureResult
        ) {
            process(partialResult)
        }
    }


    /**
     * Capture a still picture. This method should be called when we get a response in
     * [.captureCallback] from both [.lockFocus].
     */
    fun captureStillPicture(){
        try {
            if (cameraDevice == null) return
            // This is the CaptureRequest.Builder that we use to take a picture.
            var createCaptureRequest = cameraDevice?.createCaptureRequest(
                CameraDevice.TEMPLATE_STILL_CAPTURE
            )
            val captureBuilder = createCaptureRequest?.apply {
                addTarget(imageReader?.surface!!)

                // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
                // We have to take that into account and rotate JPEG properly.
                // For devices with orientation of 90, we return our mapping from ORIENTATIONS.
                // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
                set(CaptureRequest.JPEG_ORIENTATION,90)

                // Use the same AE and AF modes as the preview.
                set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
            }

            val captureCallback = object : CameraCaptureSession.CaptureCallback() {

                override fun onCaptureCompleted(session: CameraCaptureSession,
                                                request: CaptureRequest,
                                                result: TotalCaptureResult) {
                    unlockFocus()
                    mIHandleCameraListener?.capturePic(picFile.path)
                }
            }

            captureSession?.apply {
                stopRepeating()
                abortCaptures()
                capture(captureBuilder?.build()!!, captureCallback, null)
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
            mIHandleCameraListener?.error(e)
        }
    }

    /**
     * Run the precapture sequence for capturing a still image. This method should be called when
     * we get a response in [.captureCallback] from [.lockFocus].
     */
    private fun runPrecaptureSequence() {
        try {
            // This is how to tell the camera to trigger.
            previewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,
                CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START)
            // Tell #captureCallback to wait for the precapture sequence to be set.
            cameraAction = CAMERA_STATE_WAITING_PRECAPTURE
            captureSession?.capture(previewRequestBuilder.build(), captureCallback, null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
            mIHandleCameraListener?.error(e)
        }
    }



    fun closeCamera() {
        cameraDevice?.apply {
            close()
        }
    }


}